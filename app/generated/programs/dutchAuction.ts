/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
  SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
  SolanaError,
  type Address,
  type ClientWithRpc,
  type ClientWithTransactionPlanning,
  type ClientWithTransactionSending,
  type GetAccountInfoApi,
  type GetMultipleAccountsApi,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  addSelfFetchFunctions,
  addSelfPlanAndSendFunctions,
  type SelfFetchFunctions,
  type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import { getAuctionCodec, type Auction, type AuctionArgs } from "../accounts";
import {
  getBuyInstructionAsync,
  getCancelInstructionAsync,
  getInitInstructionAsync,
  parseBuyInstruction,
  parseCancelInstruction,
  parseInitInstruction,
  type BuyAsyncInput,
  type CancelAsyncInput,
  type InitAsyncInput,
  type ParsedBuyInstruction,
  type ParsedCancelInstruction,
  type ParsedInitInstruction,
} from "../instructions";

export const DUTCH_AUCTION_PROGRAM_ADDRESS =
  "BgU4SppsedWxpVqyAGyRkebCpYAZZoFsyWvNL3kgxT5u" as Address<"BgU4SppsedWxpVqyAGyRkebCpYAZZoFsyWvNL3kgxT5u">;

export enum DutchAuctionAccount {
  Auction,
}

export function identifyDutchAuctionAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): DutchAuctionAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([218, 94, 247, 242, 126, 233, 131, 81]),
      ),
      0,
    )
  ) {
    return DutchAuctionAccount.Auction;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    { accountData: data, programName: "dutchAuction" },
  );
}

export enum DutchAuctionInstruction {
  Buy,
  Cancel,
  Init,
}

export function identifyDutchAuctionInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): DutchAuctionInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([102, 6, 61, 18, 1, 218, 235, 234]),
      ),
      0,
    )
  ) {
    return DutchAuctionInstruction.Buy;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([232, 219, 223, 41, 219, 236, 220, 190]),
      ),
      0,
    )
  ) {
    return DutchAuctionInstruction.Cancel;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100]),
      ),
      0,
    )
  ) {
    return DutchAuctionInstruction.Init;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    { instructionData: data, programName: "dutchAuction" },
  );
}

export type ParsedDutchAuctionInstruction<
  TProgram extends string = "BgU4SppsedWxpVqyAGyRkebCpYAZZoFsyWvNL3kgxT5u",
> =
  | ({
      instructionType: DutchAuctionInstruction.Buy;
    } & ParsedBuyInstruction<TProgram>)
  | ({
      instructionType: DutchAuctionInstruction.Cancel;
    } & ParsedCancelInstruction<TProgram>)
  | ({
      instructionType: DutchAuctionInstruction.Init;
    } & ParsedInitInstruction<TProgram>);

export function parseDutchAuctionInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedDutchAuctionInstruction<TProgram> {
  const instructionType = identifyDutchAuctionInstruction(instruction);
  switch (instructionType) {
    case DutchAuctionInstruction.Buy: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: DutchAuctionInstruction.Buy,
        ...parseBuyInstruction(instruction),
      };
    }
    case DutchAuctionInstruction.Cancel: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: DutchAuctionInstruction.Cancel,
        ...parseCancelInstruction(instruction),
      };
    }
    case DutchAuctionInstruction.Init: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: DutchAuctionInstruction.Init,
        ...parseInitInstruction(instruction),
      };
    }
    default:
      throw new SolanaError(
        SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
        {
          instructionType: instructionType as string,
          programName: "dutchAuction",
        },
      );
  }
}

export type DutchAuctionPlugin = {
  accounts: DutchAuctionPluginAccounts;
  instructions: DutchAuctionPluginInstructions;
};

export type DutchAuctionPluginAccounts = {
  auction: ReturnType<typeof getAuctionCodec> &
    SelfFetchFunctions<AuctionArgs, Auction>;
};

export type DutchAuctionPluginInstructions = {
  buy: (
    input: BuyAsyncInput,
  ) => ReturnType<typeof getBuyInstructionAsync> & SelfPlanAndSendFunctions;
  cancel: (
    input: CancelAsyncInput,
  ) => ReturnType<typeof getCancelInstructionAsync> & SelfPlanAndSendFunctions;
  init: (
    input: InitAsyncInput,
  ) => ReturnType<typeof getInitInstructionAsync> & SelfPlanAndSendFunctions;
};

export type DutchAuctionPluginRequirements = ClientWithRpc<
  GetAccountInfoApi & GetMultipleAccountsApi
> &
  ClientWithTransactionPlanning &
  ClientWithTransactionSending;

export function dutchAuctionProgram() {
  return <T extends DutchAuctionPluginRequirements>(client: T) => {
    return {
      ...client,
      dutchAuction: <DutchAuctionPlugin>{
        accounts: { auction: addSelfFetchFunctions(client, getAuctionCodec()) },
        instructions: {
          buy: (input) =>
            addSelfPlanAndSendFunctions(client, getBuyInstructionAsync(input)),
          cancel: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getCancelInstructionAsync(input),
            ),
          init: (input) =>
            addSelfPlanAndSendFunctions(client, getInitInstructionAsync(input)),
        },
      },
    };
  };
}
